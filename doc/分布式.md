#### raft协议

##### 关键词

- 任期

- 领导者心跳信息

- 随机选举超时时间

- 先来先服务的投票原则

- 大多数选票原则

  

##### raft 基础

在任何时刻，每一个服务器节点都处于这三个状态之一：leader、follower 或者 candidate 。在正常情况下，集群中只有一个 leader 并且其他的节点全部都是 follower 。Follower 都是被动的：他们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 follower 通信，follower 会将请求重定向给 leader）。第三种状态，candidate ，是用来选举一个新的 leade

![img](https://img2018.cnblogs.com/blog/1089769/201812/1089769-20181216202049306-1194425087.png)

##### leader选举

Raft 使用一种心跳机制来触发 leader 选举。当服务器程序启动时，他们都是 follower 。一个服务器节点只要能从 leader 或 candidate 处接收到有效的 RPC 就一直保持 follower 状态。Leader 周期性地向所有 follower 发送心跳（不包含日志条目的 AppendEntries RPC）来维持自己的地位。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的 leader 。

要开始一次选举过程，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己并且并行地向集群中的其他服务器节点发送 RequestVote RPC（让其他服务器节点投票给它）。Candidate 会一直保持当前状态直到以下三件事情之一发生：(a) 它自己赢得了这次的选举（收到过半的投票），(b) 其他的服务器节点成为 leader ，(c) 一段时间之后没有任何获胜者。

当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。对于同一个任期，每个服务器节点只会投给一个 candidate ，按照先来先服务（first-come-first-served）的原则

##### 日志复制

Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 AppendEntries RPC 给其他的服务器，让它们复制该条目。当该条目被安全地复制（下面会介绍），leader 会应用该条目到它的状态机中（状态机执行该指令）然后把执行的结果返回给客户端。如果 follower 崩溃或者运行缓慢，或者网络丢包，leader 会不断地重试 AppendEntries RPC（即使已经回复了客户端）直到所有的 follower 最终都存储了所有的日志条目。

日志以图 6 展示的方式组织。每个**日志条目**存储一条**状态机指令**和 leader 收到该指令时的**任期号**。任期号用来检测多个日志副本之间的不一致情况，同时也用来保证图 3 中的某些性质。每个日志条目都有一个整数索引值来表明它在日志中的位置。



![img](https://upload-images.jianshu.io/upload_images/2509688-796b1fb1f2035c3f.png?imageMogr2/auto-orient/strip|imageView2/2/w/707/format/webp)

Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为**已提交的**。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就会被提交（例如在图 6 中的条目 7），如果不是最新term，不会把过半的复制当做已提交，因为其他节点被选举为leader后，可能会覆盖掉这些过半的日志。

> 论文 https://www.jianshu.com/p/031a67cd74c1

**应用**：

- etcd(etcd 被设计为提供高可用、强一致的小型 keyvalue 数据存储服务)用在 k8s信息存储上

- 服务发现框架consul，

- Tidb/TiKV

#### gossip协议

去中心化的分布式协议，数据通过节点像病毒一样逐个传播。最终一致性协议

Gossip协议执行过程：

- 种子节点周期性的散播消息 【假定把周期限定为 1 秒】。
- 被感染节点随机选择N个邻接节点散播消息【假定fan-out(扇出)设置为6，每次最多往6个节点散播】。
- 节点只接收消息不反馈结果。
- 每次散播消息都选择尚未发送过的节点进行散播。
- 收到消息的节点不再往发送节点散播：A -> B，那么B进行散播的时候，不再发给 A。

优势：

- 扩展性
- 容错
- 去中心化
- 一致性收敛 传播速度达到logN
- 简单

缺点:

- 消息冗余
- 消息延迟

应用：

- redis cluster 同步节点状态信息 https://zhuanlan.zhihu.com/p/92937061
- consul

> https://zhuanlan.zhihu.com/p/41228196



#### hash槽 rehash槽

##### 哈希算法最重要的特点就是：

- 相同的输入一定得到相同的输出；
- 不同的输入大概率得到不同的输出。

##### 常用的hash算法

算法|输出长度（位）|输出长度（字节)   

-|:-:|-:

MD5|128|bits|16 bytes  

SHA-1 160 bits 20 bytes 

 RipeMD-160 160 bits 20 bytes

 SHA-256 256 bits 32 bytes 

 SHA-512 512 bits 64 bytes

##### 一致性hash

一致性hash是一个**0-2^32**的闭合圆，占用4个字节（拥有2^23个桶空间，每个桶里面可以存储很多数据，可以理解为s3的存储桶）所有节点存储的数据都是不一样的。计算一致性哈希是采用的是如下步骤：

对节点进行hash,通常使用其节点的ip或者是具有唯一标示的数据进行hash(ip),将其值分布在这个闭合圆上。

将存储的key进行hash(key),然后将其值要分布在这个闭合圆上。

从hash(key)在圆上映射的位置开始顺时针方向找到的一个节点即为存储key的节点。如果到圆上的0处都未找到节点，那么0位置后的顺时针方向的第一个节点就是key的存储节点。

###### 雪崩现象 与 数据倾斜现象

雪崩现象：删除一个节点时，对应数据转移到下一个节点，下一个节点数据激增，可能会崩溃，循环往复，影响到所有节点。

数据倾斜现象：数据分布不均匀，有的及诶单多，有的节点少

解决办法：将真实节点计算多个哈希形成多个虚拟节点并放置到哈希环上。

##### hash槽

redis cluster采用数据分片的哈希槽来进行数据存储和数据的读取.edis cluster一共有2^14（16384）个槽，所有的master节点都会有一个槽区比如0～1000，槽数是可以迁移的。master节点的slave节点不分配槽，**只拥有读权限。但是注意在代码中redis cluster执行读写操作的都是master节点，并不是你想 的读是从节点，写是主节点**。第一次新建redis cluster时，16384个槽是被master节点均匀分布的。

它并不是闭合的，key的定位规则是**根据CRC-16(key)%16384的值来判断属于哪个槽区，从而判断该key属于哪个节点**

