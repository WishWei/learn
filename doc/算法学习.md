### 逆波兰计算器

后缀表达式，利用栈的入栈来进行计算，当入栈一个运算符时，出栈两个数，作为运算的两个数字；计算出结果后，将最终结果入栈到栈，直到结束即可算出结果。

参考文章：https://blog.csdn.net/sophia__yu/article/details/79835573

### 约瑟夫问题换转队列 

倒叙总结出规律，利用递归结算

>F（1）= 1
>那么，当n=2，报数到m的人出列，最后出列的人是谁？应该是只有一个人报数时得到的最后出列的序号加上m+1（因为已经有1个人出了队列，求F（n）时因为已经有n-1个人出了队列，所以需要加上n-1），可用公式表示为以下形式：
>F（2）= F（1）+ m + 1
>通过上面的算式计算时，F(2)的结果可能会超过n值（人数的总数）。例如，设n=2，m=3（即2个人，报数到3时就出列），则按上式计算得到的值是：
>F（2）= F（1）+ 3 + 1 = 1 + 3 + 1 = 5
>一共只有2人参与，编号为5的人显然没有。怎么办？由于是环状报数，因此当两个人报完数之后，又从编号为1的人开始接着报数。根据这个原理，即可对求得的值与总人数n进行模运算，然后再加上1，因为不是从0开始计数的，即：
>F（2）= [F（1）+ m + 1] % n + 1 = [1 + 3 + 1]%2 + 1 = 2
>即，n=2，m=3（即有2个人，报数到3的人出列）时，循环报数最后一个出列的人的编号为2（编号从1开始）。
>根据上面的推导过程，可以很容易推导出，当n=3时的公式：
>F（3）= [F（2）+ m + 2]%3 + 1
>同理，也可以推导出参与人数为N时，最后出列人员编号的公式：
>F（n）= [F（n-1）+ m + n - 1]%n + 1
>其实，这就是一个递推公式，公式包含以下两个式子：
>F（1）= 1；                           n=1
>F（n）= [F（n-1）+ m + n - 1]%n + 1；   n>1 

> 参考文章：https://blog.csdn.net/hs794502825/article/details/37991467

### dequene滑动窗口

利用双端队列的头部来保存当前窗口可能最大的数字下标，第一个节点时最大的，后续的节点是可能成为最大的。

先初始化第一个窗口。新加入节点时，从尾部对比加入元素，如果比新加入的元素小，则删除尾结点，循环到直到头结点。，同时还需要判断头节点是否已经划出了窗口，如果划出了，删除头结点。

### 大顶堆 小顶堆

堆是一种**非线性结构**，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲**堆其实就是利用完全二叉树的结构来维护的一维数组**

按照堆的特点可以把堆分为**大顶堆**和**小顶堆**

大顶堆：每个结点的值都**大于**或**等于**其左右孩子结点的值

小顶堆：每个结点的值都**小于**或**等于**其左右孩子结点的值

**升序----使用大顶堆**

**降序----使用小顶堆**

https://www.cnblogs.com/lanhaicode/p/10546257.html

### topk

查找size为n的数组中前k大的元素

- 全局排序，O(n*lg(n))

- 局部排序，只排序TopK个数，O(n*k)

- 堆，TopK个数也不排序了，O(n*lg(k))

- 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))

- 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)

- TopK的另一个解法：随机选择+partition

  https://www.sohu.com/a/255145095_178889

### 二叉树 两个节点的公共祖先

从根节点查找左右子节点是否包含两个节点任一，如果只有左/右包含，则返回左/右，如果左右都有，则返回根节点

>根据临界条件，实际上可以发现这道题已经被简化为查找以root为根结点的树上是否有p结点或者q结点，如果有就返回p结点或q结点，否则返回null。
>这样一来其实就很简单了，从左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：
>第一种情况：左子树和右子树均找没有p结点或者q结点；（这里特别需要注意，虽然题目上说了p结点和q结点必定都存在，但是递归的时候必须把所有情况都考虑进去，因为题目给的条件是针对于整棵树，而递归会到局部，不一定都满足整体条件）
>第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；
>第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；
>第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p||root==q||!root)return root;
        
        TreeNode* left=lowestCommonAncestor(root->left,  p, q);
        TreeNode* right=lowestCommonAncestor(root->right,  p, q);
        
        if(!left&&!right)return NULL;
        else if(left&&!right)return left;
        else if(right&&!left)return right;
        
        return root;
    }
```

```java
public static TreeNode<Integer> lowestCommonAncestor(TreeNode<Integer> root, TreeNode<Integer> p, TreeNode<Integer> q) {
        if(root == null) {
            return null;
        }
        if(root == p || root == q ) {
            return root;
        }
        TreeNode<Integer> left = lowestCommonAncestor(root.getLeft(), p ,q);
        TreeNode<Integer> right = lowestCommonAncestor(root.getRight(), p ,q);
        if(left != null && right != null) {
            return root;
        }
        if(left != null && right == null) {
            return left;
        }
        if(left == null && right != null) {
            return right;
        }
        return null;
    }
```



### B+树 

##### 区别

   (1）B+树查询时间复杂度固定是logn，B树查询复杂度最好是 O(1)。

（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

（3）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确

##### 应用

- MongoDB

MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。

- Mysql

Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。



红黑树

图 有向图 

bfs广度优先
dfs深度优先

字符串pm，km匹配算法 

动态规划 dp

nio epoll，npoll nio bio select 

环状队列
es怎么快

skiplist

redis哨兵raft协议

hash槽 rehash槽

mysql，覆盖查询

索引下推
rocketmq
Kafka

设计模式
限流 nginx做 guava writelimiter 零排同算法
熔断和探活
zk读写锁
zk 分布式pxxx协议 raft协议
这些协议
gassap协议
区块链 向量协议

lsm 

jstorm 流式计算
flink hadoop 离线计算

tcp udp 说到报文头 三次挥手 为什么3次，结束等待两个报文最大生命周期