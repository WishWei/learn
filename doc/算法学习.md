### 逆波兰计算器

后缀表达式，利用栈的入栈来进行计算，当入栈一个运算符时，出栈两个数，作为运算的两个数字；计算出结果后，将最终结果入栈到栈，直到结束即可算出结果。

参考文章：https://blog.csdn.net/sophia__yu/article/details/79835573

### 约瑟夫问题换转队列 

倒叙总结出规律，利用递归结算

>F（1）= 1
>那么，当n=2，报数到m的人出列，最后出列的人是谁？应该是只有一个人报数时得到的最后出列的序号加上m+1（因为已经有1个人出了队列，求F（n）时因为已经有n-1个人出了队列，所以需要加上n-1），可用公式表示为以下形式：
>F（2）= F（1）+ m + 1
>通过上面的算式计算时，F(2)的结果可能会超过n值（人数的总数）。例如，设n=2，m=3（即2个人，报数到3时就出列），则按上式计算得到的值是：
>F（2）= F（1）+ 3 + 1 = 1 + 3 + 1 = 5
>一共只有2人参与，编号为5的人显然没有。怎么办？由于是环状报数，因此当两个人报完数之后，又从编号为1的人开始接着报数。根据这个原理，即可对求得的值与总人数n进行模运算，然后再加上1，因为不是从0开始计数的，即：
>F（2）= [F（1）+ m + 1] % n + 1 = [1 + 3 + 1]%2 + 1 = 2
>即，n=2，m=3（即有2个人，报数到3的人出列）时，循环报数最后一个出列的人的编号为2（编号从1开始）。
>根据上面的推导过程，可以很容易推导出，当n=3时的公式：
>F（3）= [F（2）+ m + 2]%3 + 1
>同理，也可以推导出参与人数为N时，最后出列人员编号的公式：
>F（n）= [F（n-1）+ m + n - 1]%n + 1
>其实，这就是一个递推公式，公式包含以下两个式子：
>F（1）= 1；                           n=1
>F（n）= [F（n-1）+ m + n - 1]%n + 1；   n>1 

> 参考文章：https://blog.csdn.net/hs794502825/article/details/37991467

### dequene滑动窗口

利用双端队列的头部来保存当前窗口可能最大的数字下标，第一个节点时最大的，后续的节点是可能成为最大的。

先初始化第一个窗口。新加入节点时，从尾部对比加入元素，如果比新加入的元素小，则删除尾结点，循环到直到头结点。，同时还需要判断头节点是否已经划出了窗口，如果划出了，删除头结点。

### 大顶堆 小顶堆

堆是一种**非线性结构**，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲**堆其实就是利用完全二叉树的结构来维护的一维数组**

按照堆的特点可以把堆分为**大顶堆**和**小顶堆**

大顶堆：每个结点的值都**大于**或**等于**其左右孩子结点的值

小顶堆：每个结点的值都**小于**或**等于**其左右孩子结点的值

**升序----使用大顶堆**

**降序----使用小顶堆**

https://www.cnblogs.com/lanhaicode/p/10546257.html

### topk

查找size为n的数组中前k大的元素

- 全局排序，O(n*lg(n))

- 局部排序，只排序TopK个数，O(n*k)

- 堆，TopK个数也不排序了，O(n*lg(k))

- 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))

- 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)

- TopK的另一个解法：随机选择+partition

  https://www.sohu.com/a/255145095_178889

### 二叉树 两个节点的公共祖先

从根节点查找左右子节点是否包含两个节点任一，如果只有左/右包含，则返回左/右，如果左右都有，则返回根节点

>根据临界条件，实际上可以发现这道题已经被简化为查找以root为根结点的树上是否有p结点或者q结点，如果有就返回p结点或q结点，否则返回null。
>这样一来其实就很简单了，从左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：
>第一种情况：左子树和右子树均找没有p结点或者q结点；（这里特别需要注意，虽然题目上说了p结点和q结点必定都存在，但是递归的时候必须把所有情况都考虑进去，因为题目给的条件是针对于整棵树，而递归会到局部，不一定都满足整体条件）
>第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；
>第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；
>第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p||root==q||!root)return root;
        
        TreeNode* left=lowestCommonAncestor(root->left,  p, q);
        TreeNode* right=lowestCommonAncestor(root->right,  p, q);
        
        if(!left&&!right)return NULL;
        else if(left&&!right)return left;
        else if(right&&!left)return right;
        
        return root;
    }
```

```java
public static TreeNode<Integer> lowestCommonAncestor(TreeNode<Integer> root, TreeNode<Integer> p, TreeNode<Integer> q) {
        if(root == null) {
            return null;
        }
        if(root == p || root == q ) {
            return root;
        }
        TreeNode<Integer> left = lowestCommonAncestor(root.getLeft(), p ,q);
        TreeNode<Integer> right = lowestCommonAncestor(root.getRight(), p ,q);
        if(left != null && right != null) {
            return root;
        }
        if(left != null && right == null) {
            return left;
        }
        if(left == null && right != null) {
            return right;
        }
        return null;
    }
```



### B+树 

##### 区别

   (1）B+树查询时间复杂度固定是logn，B树查询复杂度最好是 O(1)。

（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

（3）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确

##### 应用

- MongoDB

MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。

- Mysql

Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。

### 红黑树

##### 应用

java的TreeMap、TreeSet、jdk1.8后的HashMap

![img](https://upload-images.jianshu.io/upload_images/272719-b99ccebc59967187.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp)

##### 特性

1. 每个节点要么是黑的，要么是红的
2. 根节点是黑的
3. 叶节点是黑的
4. 如果一个节点是红的，他的两个儿子节点都是黑的
5. 对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点

##### 新增节点

新增节点为红色，在适当位置添加后，通过一系列变色和旋转，使得红黑树符合特性，变为一个查找树

![img](https://upload-images.jianshu.io/upload_images/272719-1b01b878953c967f.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/735/format/webp)

##### 变色与旋转规则

- 当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色

  对策 :把父节点和叔叔节点变黑，爷爷节点涂红，然后把当前节点指针给到爷爷，让爷爷节点那层继续循环，接受红黑树特性检测。

- 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。

  对策：当前节点的父节点作为新的当前节点，以新当前指点为支点左旋

- 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子

  对策： 父节点变黑，祖父变红，以祖父节点为支点右旋

  > https://www.jianshu.com/p/0eaea4cc5619



### 图 有向图 

##### 邻接矩阵

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190413182435816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY2Mjk1NQ==,size_16,color_FFFFFF,t_70)

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190413182644247.png)

>
>
>邻接矩阵的存储特点：
>  （a）无向图的邻接矩阵一定是一个对称矩阵，有向图不一定是。
>*（b）邻接矩阵所需的存储空间值域只与顶点数有关系。
>  （c）用邻接矩阵存储图，容易判断两个点之间是否有边。
>  （d）如果一个有向图的邻接矩阵为三角矩阵（主对角线为0），则它的拓扑排序一定存在。
>*（e）小技巧
>
>无向图：邻接矩阵的第i行或者第i列的非零元素的个数正好是第i个顶点Vi的度；
>有向图：邻接矩阵的第i行的非零元素个数正好是第i个顶点Vi的出度，第i列非零元素的个数正好是第i个顶点Vi的入度。

##### 关联矩阵

###### 定义

设任意图G=(V,E)，其中顶点集V=v1,v2,…,vn，边集E=e1,e2,…,eε。用mij表示顶点vi与边ej关联的关系，可能取值为0,1，-1，称所得矩阵M(G)=(mij)n×ε为图G的关联矩阵。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183225495.jpg)
mij 表示i行j列，探究顶点Vi和边Ej之间的关系，形成下列的关联矩阵

###### 示例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183314317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY2Mjk1NQ==,size_16,color_FFFFFF,t_70)
关联矩阵
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183335852.png)

##### 连通图、连通分量

连通图：无向图中，若从顶点u到顶点v有路径，称为u，v是连通的。若图中任意两个顶点均是连通的，则称为连通图。
连通分量：无向图中极大连通子图称为连通分量。

##### 强连通图、强连通分量

强连通图：有向图中，若从顶点u到顶点v有路径，称为u，v是连通的。若图中任意两个顶点均是连通的，则称为强连通图。
连通分量：无向图中极大连通子图称为强连通分量。特：强连通图只有强连通分量（本身），非强连通图有多个强连通分量。

> 参考：https://blog.csdn.net/weixin_42662955/article/details/89286893

### bfs广度优先与dfs深度优先

##### bsf

一层一层蔓延，直到终点

队列，先进先出，A出队列时，未进入过队列的节点入队列

##### dsf

一条路走到底，不通在返回

> dfs(深度优先搜索)是两个搜索中先理解并使用的，其实就是暴力把所有的路径都搜索出来，它运用了回溯，保存这次的位置，深入搜索，都搜索完了便回溯回来，搜下一个位置，直到把所有最深位置都搜一遍，要注意的一点是，搜索的时候有记录走过的位置，标记完后可能要改回来

栈，先进后出，A出栈时，未进入过栈的节点入栈



### 字符串kmp匹配算法 

举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？

利用匹配字符各个子字符串的最大尾部和头部相同的字符串长度l得到一张部分表，每次匹配失败后，不用完全回溯，将匹配字符后移

**移动位数 = 已匹配的字符数 - 对应的部分匹配值**

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)

> 　－　"A"的前缀和后缀都为空集，共有元素的长度为0；
>
> 　　－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
>
> 　　－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
>
> 　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
>
> 　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
>
> 　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
>
> 　　－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html



动态规划 dp

nio epoll，npoll nio bio select 

环状队列
es怎么快

skiplist

redis哨兵raft协议

hash槽 rehash槽

mysql，覆盖查询

索引下推
rocketmq
Kafka

设计模式
限流 nginx做 guava writelimiter 零排同算法
熔断和探活
zk读写锁
zk 分布式pxxx协议 raft协议
这些协议
gassap协议
区块链 向量协议

lsm 

jstorm 流式计算
flink hadoop 离线计算

tcp udp 说到报文头 三次挥手 为什么3次，结束等待两个报文最大生命周期