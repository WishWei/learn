### 逆波兰计算器

后缀表达式，利用栈的入栈来进行计算，当入栈一个运算符时，出栈两个数，作为运算的两个数字；计算出结果后，将最终结果入栈到栈，直到结束即可算出结果。

参考文章：https://blog.csdn.net/sophia__yu/article/details/79835573

### 约瑟夫问题换转队列 

倒叙总结出规律，利用递归结算

>F（1）= 1
>那么，当n=2，报数到m的人出列，最后出列的人是谁？应该是只有一个人报数时得到的最后出列的序号加上m+1（因为已经有1个人出了队列，求F（n）时因为已经有n-1个人出了队列，所以需要加上n-1），可用公式表示为以下形式：
>F（2）= F（1）+ m + 1
>通过上面的算式计算时，F(2)的结果可能会超过n值（人数的总数）。例如，设n=2，m=3（即2个人，报数到3时就出列），则按上式计算得到的值是：
>F（2）= F（1）+ 3 + 1 = 1 + 3 + 1 = 5
>一共只有2人参与，编号为5的人显然没有。怎么办？由于是环状报数，因此当两个人报完数之后，又从编号为1的人开始接着报数。根据这个原理，即可对求得的值与总人数n进行模运算，然后再加上1，因为不是从0开始计数的，即：
>F（2）= [F（1）+ m + 1] % n + 1 = [1 + 3 + 1]%2 + 1 = 2
>即，n=2，m=3（即有2个人，报数到3的人出列）时，循环报数最后一个出列的人的编号为2（编号从1开始）。
>根据上面的推导过程，可以很容易推导出，当n=3时的公式：
>F（3）= [F（2）+ m + 2]%3 + 1
>同理，也可以推导出参与人数为N时，最后出列人员编号的公式：
>F（n）= [F（n-1）+ m + n - 1]%n + 1
>其实，这就是一个递推公式，公式包含以下两个式子：
>F（1）= 1；                           n=1
>F（n）= [F（n-1）+ m + n - 1]%n + 1；   n>1 

> 参考文章：https://blog.csdn.net/hs794502825/article/details/37991467

### dequene滑动窗口

利用双端队列的头部来保存当前窗口可能最大的数字下标，第一个节点时最大的，后续的节点是可能成为最大的。

先初始化第一个窗口。新加入节点时，从尾部对比加入元素，如果比新加入的元素小，则删除尾结点，循环到直到头结点。，同时还需要判断头节点是否已经划出了窗口，如果划出了，删除头结点。

### 大顶堆 小顶堆

堆是一种**非线性结构**，（本篇随笔主要分析堆的数组实现）可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲**堆其实就是利用完全二叉树的结构来维护的一维数组**

按照堆的特点可以把堆分为**大顶堆**和**小顶堆**

大顶堆：每个结点的值都**大于**或**等于**其左右孩子结点的值

小顶堆：每个结点的值都**小于**或**等于**其左右孩子结点的值

**升序----使用大顶堆**

**降序----使用小顶堆**

https://www.cnblogs.com/lanhaicode/p/10546257.html

### topk

查找size为n的数组中前k大的元素

- 全局排序，O(n*lg(n))

- 局部排序，只排序TopK个数，O(n*k)

- 堆，TopK个数也不排序了，O(n*lg(k))

- 分治法，每个分支“都要”递归，例如：快速排序，O(n*lg(n))

- 减治法，“只要”递归一个分支，例如：二分查找O(lg(n))，随机选择O(n)

- TopK的另一个解法：随机选择+partition

  https://www.sohu.com/a/255145095_178889

### 二叉树 两个节点的公共祖先

从根节点查找左右子节点是否包含两个节点任一，如果只有左/右包含，则返回左/右，如果左右都有，则返回根节点

>根据临界条件，实际上可以发现这道题已经被简化为查找以root为根结点的树上是否有p结点或者q结点，如果有就返回p结点或q结点，否则返回null。
>这样一来其实就很简单了，从左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：
>第一种情况：左子树和右子树均找没有p结点或者q结点；（这里特别需要注意，虽然题目上说了p结点和q结点必定都存在，但是递归的时候必须把所有情况都考虑进去，因为题目给的条件是针对于整棵树，而递归会到局部，不一定都满足整体条件）
>第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；
>第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；
>第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==p||root==q||!root)return root;
        
        TreeNode* left=lowestCommonAncestor(root->left,  p, q);
        TreeNode* right=lowestCommonAncestor(root->right,  p, q);
        
        if(!left&&!right)return NULL;
        else if(left&&!right)return left;
        else if(right&&!left)return right;
        
        return root;
    }
```

```java
public static TreeNode<Integer> lowestCommonAncestor(TreeNode<Integer> root, TreeNode<Integer> p, TreeNode<Integer> q) {
        if(root == null) {
            return null;
        }
        if(root == p || root == q ) {
            return root;
        }
        TreeNode<Integer> left = lowestCommonAncestor(root.getLeft(), p ,q);
        TreeNode<Integer> right = lowestCommonAncestor(root.getRight(), p ,q);
        if(left != null && right != null) {
            return root;
        }
        if(left != null && right == null) {
            return left;
        }
        if(left == null && right != null) {
            return right;
        }
        return null;
    }
```



### B+树 

##### 区别

   (1）B+树查询时间复杂度固定是logn，B树查询复杂度最好是 O(1)。

（2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。

（3）B+树更适合外部存储，也就是磁盘存储。由于内节点无 data 域，每个节点能索引的范围更大更精确

##### 应用

- MongoDB

MongoDB使用B树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql。

- Mysql

Mysql作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。

### 红黑树

##### 应用

java的TreeMap、TreeSet、jdk1.8后的HashMap

![img](https://upload-images.jianshu.io/upload_images/272719-b99ccebc59967187.png?imageMogr2/auto-orient/strip|imageView2/2/w/450/format/webp)

##### 特性

1. 每个节点要么是黑的，要么是红的
2. 根节点是黑的
3. 叶节点是黑的
4. 如果一个节点是红的，他的两个儿子节点都是黑的
5. 对于任一节点而言，其到叶节点树尾端NIL指针的每一条路径都包含相同数目的黑节点

##### 新增节点

新增节点为红色，在适当位置添加后，通过一系列变色和旋转，使得红黑树符合特性，变为一个查找树

![img](https://upload-images.jianshu.io/upload_images/272719-1b01b878953c967f.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/735/format/webp)

##### 变色与旋转规则

- 当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色

  对策 :把父节点和叔叔节点变黑，爷爷节点涂红，然后把当前节点指针给到爷爷，让爷爷节点那层继续循环，接受红黑树特性检测。

- 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。

  对策：当前节点的父节点作为新的当前节点，以新当前指点为支点左旋

- 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子

  对策： 父节点变黑，祖父变红，以祖父节点为支点右旋

  > https://www.jianshu.com/p/0eaea4cc5619



### 图 有向图 

##### 邻接矩阵

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190413182435816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY2Mjk1NQ==,size_16,color_FFFFFF,t_70)

![å¨è¿éæå¥å¾çæè¿°](https://img-blog.csdnimg.cn/20190413182644247.png)

>
>
>邻接矩阵的存储特点：
>  （a）无向图的邻接矩阵一定是一个对称矩阵，有向图不一定是。
>*（b）邻接矩阵所需的存储空间值域只与顶点数有关系。
>  （c）用邻接矩阵存储图，容易判断两个点之间是否有边。
>  （d）如果一个有向图的邻接矩阵为三角矩阵（主对角线为0），则它的拓扑排序一定存在。
>*（e）小技巧
>
>无向图：邻接矩阵的第i行或者第i列的非零元素的个数正好是第i个顶点Vi的度；
>有向图：邻接矩阵的第i行的非零元素个数正好是第i个顶点Vi的出度，第i列非零元素的个数正好是第i个顶点Vi的入度。

##### 关联矩阵

###### 定义

设任意图G=(V,E)，其中顶点集V=v1,v2,…,vn，边集E=e1,e2,…,eε。用mij表示顶点vi与边ej关联的关系，可能取值为0,1，-1，称所得矩阵M(G)=(mij)n×ε为图G的关联矩阵。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183225495.jpg)
mij 表示i行j列，探究顶点Vi和边Ej之间的关系，形成下列的关联矩阵

###### 示例

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183314317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY2Mjk1NQ==,size_16,color_FFFFFF,t_70)
关联矩阵
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190413183335852.png)

##### 连通图、连通分量

连通图：无向图中，若从顶点u到顶点v有路径，称为u，v是连通的。若图中任意两个顶点均是连通的，则称为连通图。
连通分量：无向图中极大连通子图称为连通分量。

##### 强连通图、强连通分量

强连通图：有向图中，若从顶点u到顶点v有路径，称为u，v是连通的。若图中任意两个顶点均是连通的，则称为强连通图。
连通分量：无向图中极大连通子图称为强连通分量。特：强连通图只有强连通分量（本身），非强连通图有多个强连通分量。

> 参考：https://blog.csdn.net/weixin_42662955/article/details/89286893

### bfs广度优先与dfs深度优先

##### bsf

一层一层蔓延，直到终点

队列，先进先出，A出队列时，未进入过队列的节点入队列

##### dsf

一条路走到底，不通在返回

> dfs(深度优先搜索)是两个搜索中先理解并使用的，其实就是暴力把所有的路径都搜索出来，它运用了回溯，保存这次的位置，深入搜索，都搜索完了便回溯回来，搜下一个位置，直到把所有最深位置都搜一遍，要注意的一点是，搜索的时候有记录走过的位置，标记完后可能要改回来

栈，先进后出，A出栈时，未进入过栈的节点入栈



### 字符串kmp匹配算法 

举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？

利用匹配字符各个子字符串的最大尾部和头部相同的字符串长度l得到一张部分表，每次匹配失败后，不用完全回溯，将匹配字符后移

**移动位数 = 已匹配的字符数 - 对应的部分匹配值**

![img](http://www.ruanyifeng.com/blogimg/asset/201305/bg2013050109.png)

> 　－　"A"的前缀和后缀都为空集，共有元素的长度为0；
>
> 　　－　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
>
> 　　－　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
>
> 　　－　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
>
> 　　－　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
>
> 　　－　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
>
> 　　－　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。

> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

##### next[j] = k 的含义

加入匹配到第j位，不匹配。对应的next[j] = k ，k为这个长度为j的子模式串的相同前缀和后缀的最大相同长度。整个模式串往后移动（j-k）位，即可移动到下个最大匹配的字符位置（尽量避免从模式串的头部匹配）

```java
public static int[] getNextArray(String t)
    {
        char[] chars = t.toCharArray();
        int next[] = new int[chars.length];
        int j=0, k=-1;
        next[0] =- 1;
        while(j < t.length() - 1)
        {
            if(k == -1 || chars[j] == chars[k]) //t[k]我有这么长的前缀，你能匹配上吗，能匹配到k就是我们的公共最大前后缀长度。要不起？那我的子前缀要得起吗 见next
            {
                j++;k++;
                next[j] = k;
            }
            else k = next[k];//走到else，说明这个子模式串并没有k个长度的公共最大前缀和后缀，k--？这样效率太低，直接求k下标对应最大相同前缀和后缀的最大相同长度作为下标。因为之前是能匹配上的，求出的next[k],前几位也是能匹配上的（前缀=后缀）
        }
        return next;
    }

public static int kmp(String s, String p) {
        int m = s.length(), n = p.length(), i = 0, j = 0;
        int[] next = getNextArray(p);
        while (i < m && j < n) {
            if (j == - 1 || s.charAt(i) == p.charAt(j)) {
                ++i; ++j;
            } else {
                //不能匹配则到查找能匹配的模式串的最大前缀，因为前缀=后缀，所以这个前缀一定是匹配的，就看移动后的j能匹配吗
                j = next[j];
            }
        }
        return (j == n) ? i - j : -1;
    }
```

> https://blog.csdn.net/dark_cy/article/details/88698736
>
> https://zhuanlan.zhihu.com/p/83334559



### 动态规划 dp

利用中间结果，一步步算到最终

>**求解的基本步骤**
>
>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。
>
>  初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态
>
>​            图1 动态规划决策过程示意图
>
>  (1)**划分阶段**：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。
>
>  (2)**确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。
>
>  (3)**确定决策并写出状态转移方程**：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
>
>  (4)**寻找边界条件**：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。
>
>   一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
>
>https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html

> 背包问题： https://blog.csdn.net/xp731574722/article/details/70766804?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2.control



##### BIO和NIO、AIO的区别

- BIO是阻塞的，NIO是非阻塞的.
- BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写
- 使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接
- AIO是非阻塞 以异步方式发起 I/O 操作。当 I/O 操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成（不懂的可以往下看）

### 零拷贝

- **传统I/O ：** 硬盘—>内核缓冲区—>用户缓冲区—>内核 **Socket** 缓冲区—>协议引擎
- **sendfile ：**硬盘—>内核缓冲区—>内核 **Socket** 缓冲区—>协议引擎
- **sendfile（DMA 收集拷贝）：**硬盘—>内核缓冲区—>协议引擎  

> https://www.cnblogs.com/sebastian-tyd/p/13581192.html



### select poll epoll

区别：

>1、支持一个进程所能打开的最大连接数
>
>select
>
>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。
>
>poll
>
>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
>
>epoll
>
>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
>
>2、FD剧增后带来的IO效率问题
>
>select
>
>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
>
>poll
>
>同上
>
>epoll
>
>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。
>
>3、 消息传递方式
>
>select
>
>内核需要将消息传递到用户空间，都需要内核拷贝动作
>
>poll
>
>同上
>
>epoll
>
>epoll通过内核和用户空间共享一块内存来实现的。
>
>**总结：**
>
>**综上，在选择select，p****oll，epoll时要根据具体的使用场合以及这三种方式的自身特点。**
>
>**1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。**
>
>**2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善** 
>
>https://www.cnblogs.com/aspirant/p/9166944.html



环状队列如何找到环
es怎么快

skiplist

redis哨兵raft协议

hash槽 rehash槽

mysql，覆盖查询

索引下推
rocketmq
Kafka

设计模式
限流 nginx做 guava writelimiter 零排同算法
熔断和探活
zk读写锁
zk 分布式pxxx协议 raft协议
这些协议
gassap协议
区块链 向量协议

lsm 

jstorm 流式计算
flink hadoop 离线计算

tcp udp 说到报文头 三次挥手 为什么3次，结束等待两个报文最大生命周期