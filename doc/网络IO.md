#### BIO和NIO、AIO的区别

- BIO是阻塞的，NIO是非阻塞的.
- BIO是面向流的，只能单向读写，NIO是面向缓冲的, 可以双向读写
- 使用BIO做Socket连接时，由于单向读写，当没有数据时，会挂起当前线程，阻塞等待，为防止影响其它连接,，需要为每个连接新建线程处理.，然而系统资源是有限的,，不能过多的新建线程，线程过多带来线程上下文的切换，从来带来更大的性能损耗，因此需要使用NIO进行BIO多路复用，使用一个线程来监听所有Socket连接，使用本线程或者其他线程处理连接
- AIO是非阻塞 以异步方式发起 I/O 操作。当 I/O 操作进行时可以去做其他操作，由操作系统内核空间提醒IO操作已完成（不懂的可以往下看）

### 零拷贝

- **传统I/O ：** 硬盘—>内核缓冲区—>用户缓冲区—>内核 **Socket** 缓冲区—>协议引擎
- **sendfile ：**硬盘—>内核缓冲区—>内核 **Socket** 缓冲区—>协议引擎
- **sendfile（DMA 收集拷贝）：**硬盘—>内核缓冲区—>协议引擎  

> https://www.cnblogs.com/sebastian-tyd/p/13581192.html



### select poll epoll

区别：

>1、支持一个进程所能打开的最大连接数
>
>select
>
>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。
>
>poll
>
>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
>
>epoll
>
>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
>
>2、FD剧增后带来的IO效率问题
>
>select
>
>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
>
>poll
>
>同上
>
>epoll
>
>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。
>
>3、 消息传递方式
>
>select
>
>内核需要将消息传递到用户空间，都需要内核拷贝动作
>
>poll
>
>同上
>
>epoll
>
>epoll通过内核和用户空间共享一块内存来实现的。
>
>**总结：**
>
>**综上，在选择select，p****oll，epoll时要根据具体的使用场合以及这三种方式的自身特点。**
>
>**1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。**
>
>**2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善** 
>
>https://www.cnblogs.com/aspirant/p/9166944.html

